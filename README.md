# SoftwareDesign-HW
Homework for HSE Software Design course

### 1. CLI, a command line bash-like interpreter. Should be run using `cli/src/interface.py`.

Основной класс в программе это Interpreter, он собственно эмулирует работу bash.

Из себя он производит парсинг через классы модуля parseutils. PipelineSplitter отвечает за преобразование пайплайна из строки в список команд, CommandExpander за преобразование команды из строки в список аргументов и раскрытие переменных. Вспомогательный класс QuoteParser энкапсулирует все технические детали парсинга кавычек.

Interpreter также вызывает команды. Все команды являются наследниками класса Command.

Interpreter с пользователем не взаимодействует, за выделение пайплайнов из ввода пользователя и вывод ему результата команд отвечает класс Interface.

![Architecture](cli/docs/diagram.png?raw=true)


### 2. Implementation of the grep command. Uses the argparse library for command line argument parsing.

После рассмотрения нескольких питоновских библиотек я выбрала для реализации grep'a argparse.

**Изначальные требования к выбранной библиотеке:**
* В других курсах уже приходилось использовать стандартную библиотеку argparse. У нее гарантированно достаточно понятная докуменация и достаточно возможностей. Хочется только понять, что нельзя быстро найти что-то еще лучше.
* Хочется, чтобы не приходилось тратить много времени на чтение документации/разбора примеров и было сразу понятно, как использовать выбранную библиотеку для решения моей задачи.
* Ввиду особенностей моей архитектуры, я собираюсь парсить аргументы командной строки не из sys.argv[1:], а из массива, который я сама передам парсеру. Надо, чтобы такая возможность библиотекой предоставлялась.

**Рассмотренные библиотеки для разбора аргументов командной строки:**
* [argparse](https://docs.python.org/3/library/argparse.html "argparse")
	One love. Делает всё, что нужно, правда код придется немного пописать.
* [getopt](https://docs.python.org/3/library/getopt.html "getopt")
	Делает примерно то же, что и сишный getopt, то есть тоже достаточно понятный интерфейс. Для разбора аргументов потребуется писать ещё больше кода, чем у argparse. Дизлайк.
* [click](https://click.palletsprojects.com/en/7.x/ "click")
	Враппер над optparse (deprecated предшественник argparse) с декораторами. В куске документации, где обсуждается "why not argparse" написано что-то сильно более сложное, чем потребуется для реализации grep. Не люблю излишние декораторы, а серьёзных преимуществ для моего юзкейса не вижу. Дизлайк.
* [Python Fire](https://github.com/google/python-fire "Python Fire")
	Милая библиотечка, которая сама превращает класс/функцию/etc в CLI, а аргументы для командной строки берет из аргументов запускаемого объекта. К сожалению, для парсинга строки не понятно, как нормально использовать. Здесь использовать не получится, но на будущее стоит запомнить.
* [docopt](https://github.com/docopt/docopt "docopt")
	Генерирует аргументы по документации одной строчкой кода, что не может не радовать. Принимает список аргументов как параметр, а это ровно то, что мой код готов дать команде grep.
  
**docopt vs argparse**
Понять насколько docopt норм сходу не получилось, поэтому я села разбираться и пытаться писать с ним.
Итого, минусы docopt'a:
* Если ему передают неверные команды, argparse выдает более вменяемую ошибку. docopt только говорит необходимый usage, что менее удобно не только юзеру, но и программисту, который пытается заставить docopt работать.
* Поэтому я убила слишком много времени (>EPS) на чтение примеров и тестов к docopt с гита до того, как код начал как-то работать.
* Нужно будет писать больше обработки ошибок, т.к. docopt в отличие от argparse даже типы вводимых значений (для флага -A) не умеет проверять.

То есть кажется, что docopt'ом в целом пользоваться можно, и как раз простые штучки типа grep'a на нем писать норм. Но расширяемость теряется, потому что что-то содержательное с ним писать не хочется, и при этом итоговый результат будет менее удобен пользователю.

Еще он не поддерживается нормально, видимо, там не очень много коммитов в репозитории.

Итого, мораль: argparse огонь и необязательно изобретать велосипед для решения задачи, с которой уже умеет справляться стандартный питон.
